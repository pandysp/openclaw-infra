---
# Filter to only active workspaces (with both repo_url and deploy_key set)
- name: Determine active workspaces
  ansible.builtin.set_fact:
    active_workspaces: >-
      {{ _openclaw_workspaces | selectattr('repo_url', 'ne', '') | selectattr('deploy_key', 'ne', '') | list }}

- name: Ensure .ssh directory exists
  ansible.builtin.file:
    path: /home/ubuntu/.ssh
    state: directory
    mode: "0700"

- name: Create config.d directory
  ansible.builtin.file:
    path: /home/ubuntu/.ssh/config.d
    state: directory
    mode: "0700"

- name: Ensure SSH config includes config.d
  ansible.builtin.lineinfile:
    path: /home/ubuntu/.ssh/config
    line: "Include config.d/*"
    insertbefore: BOF
    create: true
    mode: "0600"

- name: Create local bin directory
  ansible.builtin.file:
    path: /home/ubuntu/.local/bin
    state: directory
    mode: "0755"

- name: Ensure systemd user directory exists
  ansible.builtin.file:
    path: /home/ubuntu/.config/systemd/user
    state: directory
    mode: "0755"

# Per-workspace setup (deploy key, SSH config, git repo, sync script, systemd units)
- name: Install deploy keys
  ansible.builtin.copy:
    content: "{{ item.deploy_key }}"
    dest: "/home/ubuntu/.ssh/{{ item.key_file }}"
    mode: "0600"
  no_log: true
  loop: "{{ active_workspaces }}"
  loop_control:
    label: "{{ item.agent_id }}"

- name: Configure SSH aliases
  ansible.builtin.template:
    src: ssh-config-workspace.j2
    dest: "/home/ubuntu/.ssh/config.d/workspace-{{ item.agent_id }}"
    mode: "0600"
  loop: "{{ active_workspaces }}"
  loop_control:
    label: "{{ item.agent_id }}"

- name: Ensure workspace directories exist
  ansible.builtin.file:
    path: "{{ item.workspace_dir }}"
    state: directory
    mode: "0755"
  loop: "{{ active_workspaces }}"
  loop_control:
    label: "{{ item.agent_id }}"

- name: Check if workspace directories exist
  ansible.builtin.stat:
    path: "{{ item.workspace_dir }}"
  register: workspace_dirs
  loop: "{{ active_workspaces }}"
  loop_control:
    label: "{{ item.agent_id }}"

- name: Initialize workspace git repos
  ansible.builtin.shell: |
    set -euo pipefail
    cd "{{ item.item.workspace_dir }}"
    CHANGED=""

    if [ ! -d ".git" ]; then
      git init -b main
      CHANGED="yes"
    fi

    # Ensure branch is named 'main' (skip on empty repos where HEAD is detached)
    CURRENT_BRANCH=$(git rev-parse --abbrev-ref HEAD 2>/dev/null || echo "")
    if [ -n "$CURRENT_BRANCH" ] && [ "$CURRENT_BRANCH" != "main" ] && [ "$CURRENT_BRANCH" != "HEAD" ]; then
        git branch -m "$CURRENT_BRANCH" main
        CHANGED="yes"
    fi

    # Set per-agent git identity (local scope) — only if different
    DESIRED_NAME="OpenClaw Agent ({{ item.item.agent_id }})"
    DESIRED_EMAIL="openclaw-{{ item.item.agent_id }}@localhost"
    CURRENT_NAME=$(git config user.name 2>/dev/null || echo "")
    CURRENT_EMAIL=$(git config user.email 2>/dev/null || echo "")
    if [ "$CURRENT_NAME" != "$DESIRED_NAME" ]; then
        git config user.name "$DESIRED_NAME"
        CHANGED="yes"
    fi
    if [ "$CURRENT_EMAIL" != "$DESIRED_EMAIL" ]; then
        git config user.email "$DESIRED_EMAIL"
        CHANGED="yes"
    fi

    # Set remote URL — only if different
    ALIAS_URL=$(echo "{{ item.item.repo_url }}" | sed "s/github\.com/{{ item.item.ssh_alias }}/")
    CURRENT_URL=$(git remote get-url origin 2>/dev/null || echo "")
    if [ -z "$CURRENT_URL" ]; then
        git remote add origin "$ALIAS_URL"
        CHANGED="yes"
    elif [ "$CURRENT_URL" != "$ALIAS_URL" ]; then
        git remote set-url origin "$ALIAS_URL"
        CHANGED="yes"
    fi

    if [ -n "$CHANGED" ]; then echo "CHANGED"; else echo "OK"; fi
  args:
    executable: /bin/bash
  register: workspace_init_result
  changed_when: "'CHANGED' in workspace_init_result.stdout"
  when: item.stat.exists and item.stat.isdir
  loop: "{{ workspace_dirs.results }}"
  loop_control:
    label: "{{ item.item.agent_id }}"

- name: Create workspace .gitignore files
  ansible.builtin.copy:
    src: gitignore-workspace
    dest: "{{ item.item.workspace_dir }}/.gitignore"
    mode: "0644"
  when: item.stat.exists and item.stat.isdir
  loop: "{{ workspace_dirs.results }}"
  loop_control:
    label: "{{ item.item.agent_id }}"

- name: Migrate memory/ to logs/ (one-time rename)
  ansible.builtin.shell: |
    set -euo pipefail
    SRC="{{ item.item.workspace_dir }}/memory"
    DST="{{ item.item.workspace_dir }}/logs"
    if [ -d "$SRC" ] && [ ! -d "$DST" ]; then
      mv "$SRC" "$DST"
      echo "MIGRATED"
    else
      echo "OK"
    fi
  args:
    executable: /bin/bash
  register: memory_migration
  changed_when: "'MIGRATED' in memory_migration.stdout"
  when: item.stat.exists and item.stat.isdir
  loop: "{{ workspace_dirs.results }}"
  loop_control:
    label: "{{ item.item.agent_id }}"

- name: Migrate beads workspace from SQLite to embedded Dolt backend
  ansible.builtin.shell: |
    set -euo pipefail
    BEADS_DIR="{{ item.item.workspace_dir }}/.beads"
    BACKUP="/tmp/beads-migrate-{{ item.item.agent_id }}.jsonl"

    # beads.db is the SQLite marker — present only in v0.49.x and earlier.
    # v0.55.4 uses embedded Dolt and cannot open SQLite databases (issue #2016).
    if [ ! -f "$BEADS_DIR/beads.db" ]; then
      echo "SKIP"
      exit 0
    fi

    # The daemon in v0.49.x maintained issues.jsonl alongside the SQLite DB as part
    # of the JSONL sync pipeline. Copy it before nuking .beads/.
    if [ -f "$BEADS_DIR/issues.jsonl" ]; then
      cp "$BEADS_DIR/issues.jsonl" "$BACKUP"
    else
      touch "$BACKUP"
    fi

    # Remove the SQLite-backed store so init creates a fresh Dolt backend.
    rm -rf "$BEADS_DIR"

    cd "{{ item.item.workspace_dir }}"
    bd init --no-interactive 2>/dev/null || bd init
    bd config set sync.branch beads-sync

    # Re-import existing issues if we had any.
    if [ -s "$BACKUP" ]; then
      bd import "$BACKUP"
    fi

    # Only remove the backup after a successful import (set -e means we get
    # here only if every preceding command succeeded).
    rm -f "$BACKUP"
    echo "MIGRATED"
  args:
    executable: /bin/bash
  register: beads_migrate
  changed_when: "'MIGRATED' in beads_migrate.stdout"
  when: item.stat.exists and item.stat.isdir
  loop: "{{ workspace_dirs.results }}"
  loop_control:
    label: "{{ item.item.agent_id }}"

- name: Initialize beads in workspace
  ansible.builtin.shell: |
    set -euo pipefail
    cd "{{ item.item.workspace_dir }}"
    if [ ! -d ".beads" ]; then
      bd init --no-interactive 2>/dev/null || bd init
      bd config set sync.branch beads-sync
      echo "INITIALIZED"
    else
      echo "OK"
    fi
  args:
    executable: /bin/bash
  register: beads_init
  changed_when: "'INITIALIZED' in beads_init.stdout"
  when: item.stat.exists and item.stat.isdir
  loop: "{{ workspace_dirs.results }}"
  loop_control:
    label: "{{ item.item.agent_id }}"

- name: Inject Beads task system into AGENTS.md
  ansible.builtin.blockinfile:
    path: "{{ item.item.workspace_dir }}/AGENTS.md"
    marker: "<!-- {mark} beads-task-system -->"
    insertbefore: "^## Safety"
    block: |
      ## Task System

      **Beads is the canonical task system.** All actionable work is tracked as Beads issues. `TODO.md` is no longer used.

      - `bd ready` — Show issues ready to work (no blockers)
      - `bd blocked` — Show blocked issues
      - `bd create --title="..." --type=task --priority=2` — Create issue (priority: 0=critical, 4=backlog)
      - `bd update <id> --status=in_progress` — Claim work
      - `bd close <id>` — Mark complete
      - `bd sync` — Sync with git remote (run at session end)

      Run `bd prime` at session start for full Beads context.
  when: item.stat.exists and item.stat.isdir
  loop: "{{ workspace_dirs.results }}"
  loop_control:
    label: "{{ item.item.agent_id }}"

- name: Add sandbox path workaround to AGENTS.md
  ansible.builtin.blockinfile:
    path: "{{ item.item.workspace_dir }}/AGENTS.md"
    marker: "<!-- {mark} sandbox-path-workaround -->"
    insertafter: "^## Safety"
    block: |
      ## File Operations (Sandbox Bug Workaround)

      There is a known OpenClaw bug (#9560) where the Read/Write/Edit tools
      validate paths against the host filesystem path instead of the container path.

      **Always use RELATIVE paths for file operations:**
      - `SOUL.md` not `/workspace/SOUL.md`
      - `logs/2026-02-11.md` not `/workspace/logs/2026-02-11.md`
      - `subdir/file.txt` not `/home/ubuntu/.openclaw/workspace/subdir/file.txt`

      Your working directory is already the workspace root. Relative paths work
      correctly. Absolute paths (both /workspace/... and /home/ubuntu/...) will
      be rejected with "escapes sandbox root."

      The exec tool (shell commands) is NOT affected -- absolute /workspace/ paths
      work fine in exec since it runs inside the container.
  when: item.stat.exists and item.stat.isdir
  loop: "{{ workspace_dirs.results }}"
  loop_control:
    label: "{{ item.item.agent_id }}"

- name: Add sandbox environment guide to AGENTS.md
  ansible.builtin.blockinfile:
    path: "{{ item.item.workspace_dir }}/AGENTS.md"
    marker: "<!-- {mark} sandbox-environment -->"
    insertafter: "<!-- END sandbox-path-workaround -->"
    block: |
      ## Sandbox Environment

      You run inside a Docker container with a writable filesystem.

      ### Installing Packages

      Installs outside `/workspace/` are **ephemeral** — destroyed on container restart
      (gateway restart, reprovisioning). Fine for one-off tasks.

      **One-off tools** — use `uvx` (runs without installing):
      ```
      uvx cowsay hello
      uvx ruff check .
      ```

      **Persistent installs** — install to `/workspace/` so they survive restarts:

      - **Python:** `uv venv /workspace/.venv && source /workspace/.venv/bin/activate && uv pip install <pkg>`
        (next session: `source /workspace/.venv/bin/activate`)
      - **Python (target):** `uv pip install --target /workspace/.packages <pkg>`
        (set `PYTHONPATH=/workspace/.packages:$PYTHONPATH PATH=/workspace/.packages/bin:$PATH`)
      - **npm:** `npm install --prefix /workspace/.npm-packages -g <pkg>`
        (set `PATH=/workspace/.npm-packages/bin:$PATH`)
      - **Binaries:** download to `/workspace/.bin/` and add to PATH

      **Rule of thumb:** Need it tomorrow → `/workspace/`. One-off → `uvx` or install normally.

      ### Filesystem Access

      - **Writable:** `/home/node/`, `/workspace/`, `/tmp/`, `/var/tmp/`
      - **Read-only:** `/usr/bin/`, `/etc/`, `/usr/lib/` (root-owned, you're UID 1000)
      - **Network:** Outbound internet (bridge). No access to host services.
      - **Isolation:** Only `/workspace/` is mounted from host. No gateway config, no other agents.
  when: item.stat.exists and item.stat.isdir
  loop: "{{ workspace_dirs.results }}"
  loop_control:
    label: "{{ item.item.agent_id }}"

- name: Initial workspace commit and push
  ansible.builtin.shell: |
    set -euo pipefail
    cd "{{ item.item.workspace_dir }}"

    # Rename branch to main if needed (handles git default of master)
    CURRENT=$(git rev-parse --abbrev-ref HEAD 2>/dev/null || echo "")
    if [ "$CURRENT" != "main" ] && [ -n "$CURRENT" ]; then
        git branch -m "$CURRENT" main
    fi

    # Commit any local changes (Ansible-written templates, etc.)
    git add -A
    if ! git diff --cached --quiet; then
        git commit -m "Initial workspace sync"
    fi

    # Reconcile with remote before pushing (local workspace takes precedence on conflict).
    # Uses merge (not rebase) — simpler for auto-synced workspaces, avoids rebase complexity.
    RECONCILED=true
    if git fetch origin main 2>/dev/null; then
        if git rev-parse --verify origin/main >/dev/null 2>&1; then
            if ! git merge -X ours origin/main --no-edit 2>/dev/null; then
                git merge --abort 2>/dev/null || true
                RECONCILED=false
            fi
        fi
    fi

    # Push (force-with-lease if reconciliation failed, normal otherwise)
    LOCAL=$(git rev-parse HEAD 2>/dev/null) || LOCAL=""
    REMOTE=$(git rev-parse origin/main 2>/dev/null) || REMOTE=""
    if [ "$LOCAL" != "$REMOTE" ]; then
        if [ "$RECONCILED" = "false" ]; then
            echo "WARNING: Conflict in {{ item.item.agent_id }}, force-pushing local state" >&2
            git push -u --force-with-lease origin main
        else
            git push -u origin main
        fi
    else
        echo "Nothing to push"
    fi
  args:
    executable: /bin/bash
  changed_when: false
  when: item.stat.exists and item.stat.isdir
  loop: "{{ workspace_dirs.results }}"
  loop_control:
    label: "{{ item.item.agent_id }}"

- name: Install workspace sync scripts
  ansible.builtin.template:
    src: workspace-git-sync.sh.j2
    dest: "/home/ubuntu/.local/bin/workspace-git-sync-{{ item.agent_id }}.sh"
    mode: "0755"
  loop: "{{ active_workspaces }}"
  loop_control:
    label: "{{ item.agent_id }}"

- name: Install workspace sync systemd services
  ansible.builtin.template:
    src: workspace-git-sync.service.j2
    dest: "/home/ubuntu/.config/systemd/user/workspace-git-sync-{{ item.agent_id }}.service"
    mode: "0644"
  loop: "{{ active_workspaces }}"
  loop_control:
    label: "{{ item.agent_id }}"
  notify: reload user systemd

- name: Install workspace sync systemd timers
  ansible.builtin.template:
    src: workspace-git-sync.timer.j2
    dest: "/home/ubuntu/.config/systemd/user/workspace-git-sync-{{ item.agent_id }}.timer"
    mode: "0644"
  loop: "{{ active_workspaces }}"
  loop_control:
    label: "{{ item.agent_id }}"
  notify:
    - reload user systemd
    - enable workspace timers

# Clean up legacy single-workspace files (from before multi-agent refactor)
- name: Stop legacy workspace timer if active
  ansible.builtin.systemd:
    name: workspace-git-sync.timer
    state: stopped
    enabled: false
    scope: user
  environment:
    XDG_RUNTIME_DIR: "/run/user/1000"
  failed_when: false

- name: Remove legacy workspace files
  ansible.builtin.file:
    path: "{{ item }}"
    state: absent
  loop:
    - /home/ubuntu/.config/systemd/user/workspace-git-sync.service
    - /home/ubuntu/.config/systemd/user/workspace-git-sync.timer
    - /home/ubuntu/.local/bin/workspace-git-sync.sh
    - /home/ubuntu/.ssh/config.d/workspace
  notify: reload user systemd
