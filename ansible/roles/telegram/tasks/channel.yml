---
- name: Write Telegram bot token to dedicated file
  ansible.builtin.copy:
    content: "{{ telegram_bot_token }}"
    dest: "{{ ansible_env.HOME }}/.openclaw/.telegram-bot-token"
    mode: "0600"
  no_log: true
  changed_when: false

- name: Set Telegram bot token
  ansible.builtin.shell: |
    set -euo pipefail
    export XDG_RUNTIME_DIR=/run/user/1000
    CHANGED=""
    DESIRED_TOKEN_FILE="{{ ansible_env.HOME }}/.openclaw/.telegram-bot-token"
    CURRENT_TOKEN_FILE=$(openclaw config get channels.telegram.tokenFile 2>/dev/null) || CURRENT_TOKEN_FILE=""
    if [ "$CURRENT_TOKEN_FILE" != "$DESIRED_TOKEN_FILE" ]; then
        openclaw config set channels.telegram.tokenFile "$DESIRED_TOKEN_FILE"
        CHANGED="yes"
    fi
    # Remove inline botToken if present (superseded by tokenFile)
    openclaw config unset channels.telegram.botToken 2>/dev/null || true
    ENABLED=$(openclaw config get channels.telegram.enabled 2>/dev/null) || ENABLED=""
    if [ "$ENABLED" != "true" ]; then
        openclaw config set channels.telegram.enabled true
        CHANGED="yes"
    fi
    if [ -n "$CHANGED" ]; then echo "UPDATED"; else echo "OK"; fi
  args:
    executable: /bin/bash
  no_log: true
  register: telegram_token_result
  changed_when: "'UPDATED' in telegram_token_result.stdout"
  notify: restart openclaw-gateway

- name: Configure Telegram channel policies
  ansible.builtin.shell: |
    set -euo pipefail
    export XDG_RUNTIME_DIR=/run/user/1000
    CHANGED=""

    # DM policy
    CURRENT_DM=$(openclaw config get channels.telegram.dmPolicy 2>/dev/null) || CURRENT_DM=""
    if [ "$CURRENT_DM" != "allowlist" ]; then
        openclaw config set channels.telegram.dmPolicy "allowlist"
        CHANGED="yes"
    fi

    # Stream mode: partial for draft message streaming
    CURRENT_SM=$(openclaw config get channels.telegram.streamMode 2>/dev/null) || CURRENT_SM=""
    if [ "$CURRENT_SM" != "partial" ]; then
        openclaw config set channels.telegram.streamMode "partial"
        CHANGED="yes"
    fi

    # Disable config writes via Telegram for security
    CURRENT_CW=$(openclaw config get channels.telegram.configWrites 2>/dev/null) || CURRENT_CW=""
    if [ "$CURRENT_CW" != "false" ]; then
        openclaw config set channels.telegram.configWrites false
        CHANGED="yes"
    fi

    # Chunk mode: split on paragraph boundaries
    CURRENT_CM=$(openclaw config get channels.telegram.chunkMode 2>/dev/null) || CURRENT_CM=""
    if [ "$CURRENT_CM" != "newline" ]; then
        openclaw config set channels.telegram.chunkMode "newline"
        CHANGED="yes"
    fi

    # Clear per-account config (bindings now use peer matching, not accountId,
    # so all messages go through the default account with the flat botToken).
    output=$(openclaw config unset channels.telegram.accounts 2>&1) || {
        if echo "$output" | grep -qi "not set\|not found\|does not exist"; then
            true
        else
            echo "ERROR: Failed to unset channels.telegram.accounts: $output" >&2
            exit 1
        fi
    }

    # Build DM allowFrom list from telegram agents with DM deliver_to
    {% set dm_allow = [] %}
    {% for agent in openclaw_agents %}
    {%   if (agent.deliver_channel | default('telegram')) == 'telegram' and agent.deliver_type == 'dm' and agent.deliver_to | default('') | length > 0 %}
    {%     set _ = dm_allow.append(agent.deliver_to | int) %}
    {%   endif %}
    {% endfor %}
    {% if dm_allow | length > 0 %}
    DESIRED_ALLOW='{{ dm_allow | to_json }}'
    CURRENT_ALLOW=$(openclaw config get channels.telegram.allowFrom 2>/dev/null) || CURRENT_ALLOW="[]"
    C_NORM=$(echo "$CURRENT_ALLOW" | jq -cS '.' 2>/dev/null || echo "PARSE_FAIL")
    D_NORM=$(echo "$DESIRED_ALLOW" | jq -cS '.')
    if [ "$C_NORM" = "PARSE_FAIL" ] || [ "$C_NORM" != "$D_NORM" ]; then
        openclaw config set channels.telegram.allowFrom --json "$DESIRED_ALLOW"
        CHANGED="yes"
    fi
    {% endif %}

    # Configure group chats (iterate telegram group-type agents with a deliver_to)
    {% set group_agents = [] %}
    {% for agent in openclaw_agents %}
    {%   if (agent.deliver_channel | default('telegram')) == 'telegram' and agent.deliver_type == 'group' and agent.deliver_to | default('') | length > 0 %}
    {%     set _ = group_agents.append(agent) %}
    {%   endif %}
    {% endfor %}
    {% if group_agents | length > 0 %}
    {% set group_allow = [] %}
    {% for agent in openclaw_agents %}
    {%   if (agent.deliver_channel | default('telegram')) == 'telegram' and agent.deliver_to | default('') | length > 0 and agent.deliver_type == 'dm' %}
    {%     set _ = group_allow.append(agent.deliver_to | int) %}
    {%   endif %}
    {% endfor %}
    CURRENT_GP=$(openclaw config get channels.telegram.groupPolicy 2>/dev/null) || CURRENT_GP=""
    if [ "$CURRENT_GP" != "allowlist" ]; then
        openclaw config set channels.telegram.groupPolicy "allowlist"
        CHANGED="yes"
    fi
    {% set groups_dict = {} %}
    {% for ga in group_agents %}
    {%   set _ = groups_dict.update({ga.deliver_to: {"allowFrom": group_allow, "requireMention": false}}) %}
    {% endfor %}
    DESIRED_GROUPS='{{ groups_dict | to_json }}'
    CURRENT_GROUPS=$(openclaw config get channels.telegram.groups 2>/dev/null) || CURRENT_GROUPS="{}"
    CG_NORM=$(echo "$CURRENT_GROUPS" | jq -cS '.' 2>/dev/null || echo "PARSE_FAIL")
    DG_NORM=$(echo "$DESIRED_GROUPS" | jq -cS '.')
    if [ "$CG_NORM" = "PARSE_FAIL" ] || [ "$CG_NORM" != "$DG_NORM" ]; then
        openclaw config set channels.telegram.groups --json "$DESIRED_GROUPS"
        CHANGED="yes"
    fi
    {% endif %}

    if [ -n "$CHANGED" ]; then echo "UPDATED"; else echo "OK"; fi
  args:
    executable: /bin/bash
  register: telegram_policies_result
  changed_when: "'UPDATED' in telegram_policies_result.stdout"
  notify: restart openclaw-gateway
