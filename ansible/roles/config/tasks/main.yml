---
- name: Write secrets and config to temp files
  ansible.builtin.copy:
    content: "{{ item.content }}"
    dest: "{{ item.dest }}"
    mode: "0600"
  no_log: true
  changed_when: false
  loop:
    - content: "{{ gateway_token }}"
      dest: /tmp/ansible-gateway-token
    - content: "{{ xai_api_key | default('') }}"
      dest: /tmp/ansible-xai-api-key
    - content: "{{ groq_api_key | default('') }}"
      dest: /tmp/ansible-groq-api-key
    - content: >-
        {% if groq_api_key is defined and groq_api_key | length > 0 -%}
        {{ openclaw_custom_models | combine({'providers': {'groq': {'baseUrl': openclaw_groq_base_url, 'apiKey': groq_api_key, 'models': []}}}, recursive=true) | to_json }}
        {%- else -%}
        {{ openclaw_custom_models | to_json }}
        {%- endif %}
      dest: /tmp/ansible-custom-models
    - content: "{{ openclaw_model_fallbacks | to_json }}"
      dest: /tmp/ansible-model-fallbacks
    - content: >-
        {{ {'enabled': openclaw_compaction_memory_flush,
            'softThresholdTokens': openclaw_compaction_memory_flush_threshold,
            'prompt': openclaw_compaction_memory_flush_prompt,
            'systemPrompt': openclaw_compaction_memory_flush_system_prompt} | to_json }}
      dest: /tmp/ansible-compaction-memoryflush

- name: Configure gateway with secret cleanup
  block:
    - name: Configure gateway secrets (auth tokens, API keys)
      ansible.builtin.shell: |
        set -euo pipefail
        export XDG_RUNTIME_DIR=/run/user/1000
        GATEWAY_TOKEN=$(cat /tmp/ansible-gateway-token)
        XAI_API_KEY=$(cat /tmp/ansible-xai-api-key)
        CHANGED=""
        HASH_DIR="/home/ubuntu/.openclaw/.ansible-hashes"
        mkdir -p "$HASH_DIR"

        # Helper: hash-file comparison for secrets (config get redacts secrets,
        # so we store the hash of what we SET and compare on next run)
        check_set_secret() {
            local key="$1" value="$2" hash_name="$3"
            local desired_hash current_hash
            desired_hash=$(echo -n "$value" | sha256sum | cut -d' ' -f1)
            current_hash=$(cat "$HASH_DIR/$hash_name" 2>/dev/null) || current_hash=""
            if [ "$desired_hash" != "$current_hash" ]; then
                openclaw config set "$key" "$value"
                echo "$desired_hash" > "$HASH_DIR/$hash_name"
                CHANGED="yes"
            fi
        }

        # Auth: token mode
        CURRENT_MODE=$(openclaw config get gateway.auth.mode 2>/dev/null) || CURRENT_MODE=""
        if [ "$CURRENT_MODE" != "token" ]; then
            openclaw config set gateway.auth.mode token
            CHANGED="yes"
        fi

        # Gateway auth + remote tokens (redacted by config get)
        check_set_secret gateway.auth.token "$GATEWAY_TOKEN" gateway-auth-token
        check_set_secret gateway.remote.token "$GATEWAY_TOKEN" gateway-remote-token

        # Web search (Grok / xAI)
        {% if xai_api_key is defined and xai_api_key | length > 0 %}
        if [ -z "$XAI_API_KEY" ]; then
            echo "ERROR: xAI API key template was non-empty but runtime value is empty"
            exit 1
        fi
        CURRENT_PROVIDER=$(openclaw config get tools.web.search.provider 2>/dev/null) || CURRENT_PROVIDER=""
        if [ "$CURRENT_PROVIDER" != "grok" ]; then
            openclaw config set tools.web.search.provider grok
            CHANGED="yes"
        fi
        check_set_secret tools.web.search.grok.apiKey "$XAI_API_KEY" xai-api-key
        CURRENT_TIMEOUT=$(openclaw config get tools.web.search.timeoutSeconds 2>/dev/null) || CURRENT_TIMEOUT=""
        if [ "$CURRENT_TIMEOUT" != "60" ]; then
            openclaw config set tools.web.search.timeoutSeconds 60
            CHANGED="yes"
        fi
        # Clean up old Brave config path (idempotent for fresh installs)
        openclaw config unset tools.web.search.apiKey 2>/dev/null || true
        {% else %}
        for key in tools.web.search.provider tools.web.search.apiKey tools.web.search.grok.apiKey tools.web.search.timeoutSeconds; do
            output=$(openclaw config unset "$key" 2>&1) && {
                CHANGED="yes"
            } || {
                if echo "$output" | grep -qi "not set\|not found\|does not exist"; then
                    true
                else
                    echo "ERROR: Failed to unset $key: $output"
                    exit 1
                fi
            }
        done
        {% endif %}

        # Voice transcription — Groq provider cleanup (setting is in the settings task,
        # after "openclaw config set models --json" which replaces the entire models object)
        {% if not (groq_api_key is defined and groq_api_key | length > 0) %}
        for key in models.providers.groq tools.media.audio.enabled tools.media.audio.models; do
            output=$(openclaw config unset "$key" 2>&1) && {
                CHANGED="yes"
            } || {
                if echo "$output" | grep -qi "not set\|not found\|does not exist"; then
                    true
                else
                    echo "ERROR: Failed to unset $key: $output"
                    exit 1
                fi
            }
        done
        {% endif %}

        if [ -n "$CHANGED" ]; then echo "UPDATED"; else echo "OK"; fi
      args:
        executable: /bin/bash
      no_log: true
      register: config_secrets
      changed_when: "'UPDATED' in config_secrets.stdout"
      notify: restart openclaw-gateway

    - name: Check daemon service file token matches gateway.auth.token
      ansible.builtin.shell: |
        set -euo pipefail
        export XDG_RUNTIME_DIR=/run/user/1000
        SERVICE_FILE="/home/ubuntu/.config/systemd/user/openclaw-gateway.service"
        [ -f "$SERVICE_FILE" ] || { echo "SKIP: no service file"; exit 0; }

        # Extract token from service file Environment= line
        SERVICE_TOKEN=$(grep -oP 'OPENCLAW_GATEWAY_TOKEN=\K[^\s"]+' "$SERVICE_FILE" 2>/dev/null) || SERVICE_TOKEN=""
        [ -n "$SERVICE_TOKEN" ] || { echo "SKIP: no token in service file"; exit 0; }

        # Get current config token (read from JSON file — config get redacts secrets)
        CONFIG_TOKEN=$(jq -r '.gateway.auth.token // empty' /home/ubuntu/.openclaw/openclaw.json 2>/dev/null) || CONFIG_TOKEN=""
        [ -n "$CONFIG_TOKEN" ] || { echo "SKIP: no config token"; exit 0; }

        # Compare via SHA-256 hash
        SERVICE_HASH=$(echo -n "$SERVICE_TOKEN" | sha256sum | cut -d' ' -f1)
        CONFIG_HASH=$(echo -n "$CONFIG_TOKEN" | sha256sum | cut -d' ' -f1)

        if [ "$SERVICE_HASH" != "$CONFIG_HASH" ]; then
            openclaw daemon install --force
            systemctl --user daemon-reload
            echo "REGENERATED: service file token updated to match gateway.auth.token"
        else
            echo "OK"
        fi
      args:
        executable: /bin/bash
      no_log: true
      register: daemon_token_sync
      changed_when: "'REGENERATED' in daemon_token_sync.stdout"
      notify: restart openclaw-gateway

    - name: Configure gateway settings
      ansible.builtin.shell: |
        set -euo pipefail
        export XDG_RUNTIME_DIR=/run/user/1000
        CHANGED=""

        # Helper: compare scalar config value, set if different
        check_set() {
            local key="$1" desired="$2"
            local current
            current=$(openclaw config get "$key" 2>/dev/null) || current=""
            if [ "$current" != "$desired" ]; then
                openclaw config set "$key" "$desired"
                CHANGED="yes"
            fi
        }

        # Helper: compare JSON config value (normalized), set if different
        check_set_json() {
            local key="$1" desired="$2"
            local current c_norm d_norm
            current=$(openclaw config get "$key" 2>/dev/null) || current=""
            c_norm=$(echo "$current" | jq -cS '.' 2>/dev/null || echo "PARSE_FAIL")
            d_norm=$(echo "$desired" | jq -cS '.')
            if [ "$c_norm" = "PARSE_FAIL" ] || [ "$c_norm" != "$d_norm" ]; then
                openclaw config set "$key" --json "$desired"
                CHANGED="yes"
            fi
        }

        # Tailscale Serve
        check_set gateway.tailscale.mode serve
        check_set gateway.tailscale.resetOnExit true

        # Trusted proxies: localhost + Tailscale CGNAT range
        check_set_json gateway.trustedProxies '["127.0.0.1", "100.64.0.0/10"]'

        # Control UI
        check_set gateway.controlUi.enabled true
        check_set gateway.controlUi.allowInsecureAuth false

        # Auth: Tailscale identity
        check_set gateway.auth.allowTailscale true

        # Model defaults
        check_set agents.defaults.model.primary "{{ openclaw_model_primary }}"
        check_set_json agents.defaults.model.fallbacks "$(cat /tmp/ansible-model-fallbacks)"
        check_set agents.defaults.thinkingDefault "{{ openclaw_thinking_default }}"

        # Custom models: hash-based comparison (server enriches config with extra fields,
        # so direct JSON comparison always finds a diff). Hash the desired value instead.
        # When Groq voice is configured, the Groq provider is merged into the temp file at template time.
        DESIRED_MODELS=$(cat /tmp/ansible-custom-models)
        HASH_DIR="/home/ubuntu/.openclaw/.ansible-hashes"
        mkdir -p "$HASH_DIR"
        DESIRED_HASH=$(echo "$DESIRED_MODELS" | jq -cS '.' | sha256sum | cut -d' ' -f1)
        CURRENT_HASH=$(cat "$HASH_DIR/custom-models" 2>/dev/null) || CURRENT_HASH=""
        if [ "$DESIRED_HASH" != "$CURRENT_HASH" ]; then
            openclaw config set models --json "$DESIRED_MODELS"
            echo "$DESIRED_HASH" > "$HASH_DIR/custom-models"
            CHANGED="yes"
        fi

        # Sandbox tool allowlist (all groups + plugins)
        {% set tool_allow = ["group:openclaw","group:runtime","group:fs","group:sessions","group:memory","group:web","group:ui","group:automation","group:messaging","group:nodes"] %}
        {% if openclaw_mcp_adapter is defined %}
        {%   set _ = tool_allow.append("group:plugins") %}
        {%   set _ = tool_allow.append("openclaw-mcp-adapter") %}
        {% endif %}
        check_set_json tools.sandbox.tools.allow '{{ tool_allow | to_json }}'

        # Plugin loading allowlist — only trusted plugins can load into gateway
        # Includes bundled plugins (device-pair, memory-core, etc.) because
        # plugins.allow blocks ALL plugins not listed, including bundled ones.
        {% set plugin_allow = ["device-pair","memory-core","phone-control","talk-voice","telegram"] %}
        {% if openclaw_agents | selectattr('deliver_channel', 'defined') | selectattr('deliver_channel', 'equalto', 'whatsapp') | list | length > 0 %}
        {%   set _ = plugin_allow.append("whatsapp") %}
        {% endif %}
        {% if openclaw_mcp_adapter is defined %}
        {%   set _ = plugin_allow.append("openclaw-mcp-adapter") %}
        {% endif %}
        check_set_json plugins.allow '{{ plugin_allow | to_json }}'

        # Elevated tools — DISABLED to prevent sandbox escape to VPS host.
        # elevated=true on exec calls bypasses tools.exec.host and grants root.
        check_set tools.elevated.enabled false
        {% set elevated_users = [] %}
        {% if telegram_user_id is defined and telegram_user_id | length > 0 %}
        {%   set _ = elevated_users.append(telegram_user_id | int) %}
        {% endif %}
        {% if elevated_users | length > 0 %}
        check_set_json tools.elevated.allowFrom.telegram '{{ elevated_users | to_json }}'
        {% endif %}
        {% set whatsapp_elevated = [] %}
        {% for agent in openclaw_agents %}
        {%   if (agent.deliver_channel | default('telegram')) == 'whatsapp' and agent.deliver_to | default('') | length > 0 %}
        {%     set _ = whatsapp_elevated.append(agent.deliver_to) %}
        {%   endif %}
        {% endfor %}
        {% if whatsapp_elevated | length > 0 %}
        check_set_json tools.elevated.allowFrom.whatsapp '{{ whatsapp_elevated | to_json }}'
        {% endif %}
        {% set discord_elevated = [] %}
        {% if discord_user_id is defined and discord_user_id | length > 0 %}
        {%   set _ = discord_elevated.append(discord_user_id) %}
        {% endif %}
        {% if discord_elevated | length > 0 %}
        check_set_json tools.elevated.allowFrom.discord '{{ discord_elevated | to_json }}'
        {% endif %}

        # Elevated default
        check_set agents.defaults.elevatedDefault "{{ openclaw_elevated_default }}"

        # Timezone
        check_set agents.defaults.userTimezone "{{ openclaw_timezone }}"
        check_set agents.defaults.envelopeTimezone user

        # Agent timeout: max seconds per conversation turn (default 600 = 10min)
        check_set agents.defaults.timeoutSeconds "{{ openclaw_agent_timeout_seconds }}"

        # Heartbeat interval
        check_set agents.defaults.heartbeat.every "{{ openclaw_heartbeat_interval }}"
        check_set agents.defaults.heartbeat.model "anthropic/claude-sonnet-4-20250514"

        # Message queue: collect messages while agent is busy, coalesce into one followup turn
        check_set messages.queue.mode collect

        # Auth cooldown: reset error count after N hours
        # Prevents timeouts from compounding into multi-hour lockouts
        check_set auth.cooldowns.failureWindowHours "{{ openclaw_cooldown_failure_window_hours }}"

        # Concurrency: allow more parallel sessions across all agents
        check_set agents.defaults.maxConcurrent "{{ openclaw_max_concurrent }}"
        check_set agents.defaults.subagents.maxConcurrent "{{ openclaw_subagents_max_concurrent }}"

        # Context pruning: trim stale tool outputs after 15m, keep last 3 assistant responses
        check_set agents.defaults.contextPruning.mode cache-ttl
        check_set agents.defaults.contextPruning.ttl 15m
        check_set agents.defaults.contextPruning.keepLastAssistants "3"

        # Compaction safeguard: flush memories before context compression
        # Prevents silent loss of in-context state (see openclaw/openclaw#5429)
        check_set agents.defaults.compaction.mode "{{ openclaw_compaction_mode }}"
        check_set agents.defaults.compaction.reserveTokensFloor "{{ openclaw_compaction_reserve_tokens_floor }}"
        check_set_json agents.defaults.compaction.memoryFlush "$(cat /tmp/ansible-compaction-memoryflush)"

        # Exec configuration (applies to both sandbox and node exec)
        # NOTE: Gateway sends VPS workspace path as CWD to nodes — does not exist on Mac.
        # Agents must pass workdir=/tmp in exec calls. See openclaw/openclaw#15441.
        # v2026.2.26: node rejects symlink CWDs, so DEFAULT_CWD=/private/tmp in MCP env.
        check_set tools.exec.host "{{ openclaw_exec_host }}"
        check_set tools.exec.security "{{ openclaw_exec_security }}"
        check_set tools.exec.ask "{{ openclaw_exec_ask }}"

        {% if not (node_exec_enabled | default(false)) %}
        # Node exec disabled — clean up any stale node pin
        openclaw config unset tools.exec.node 2>/dev/null || true
        {% endif %}

        # Sandbox configuration
        check_set agents.defaults.sandbox.mode "{{ openclaw_sandbox_mode }}"
        check_set agents.defaults.sandbox.workspaceAccess "{{ openclaw_sandbox_workspace_access }}"
        check_set agents.defaults.sandbox.docker.network "{{ openclaw_sandbox_docker_network }}"
        check_set agents.defaults.sandbox.docker.image "{{ openclaw_sandbox_docker_image }}"
        check_set_json agents.defaults.sandbox.docker.readOnlyRoot '{{ openclaw_sandbox_read_only_root | to_json }}'

        # Voice transcription — enable audio (provider merged into models JSON above; cleanup in secrets task)
        {% if groq_api_key is defined and groq_api_key | length > 0 %}
        check_set tools.media.audio.enabled true
        check_set_json tools.media.audio.models '[{"provider":"{{ openclaw_audio_provider }}","model":"{{ openclaw_audio_model }}"}]'
        {% endif %}

        if [ -n "$CHANGED" ]; then echo "UPDATED"; else echo "OK"; fi
      args:
        executable: /bin/bash
      register: config_settings
      changed_when: "'UPDATED' in config_settings.stdout"
      notify: restart openclaw-gateway

    - name: Auto-discover connected system node for exec
      when: node_exec_enabled | default(false)
      ansible.builtin.shell: |
        set -euo pipefail
        export XDG_RUNTIME_DIR=/run/user/1000

        # Step 1: Get nodes status JSON (fail visibly if gateway is down)
        NODES_RAW=$(openclaw nodes status --json 2>&1) || {
            echo "WARNING: 'openclaw nodes status --json' failed (rc=$?): $NODES_RAW"
            echo "  Gateway may not be running. Check: systemctl --user status openclaw-gateway"
            NODES_RAW=""
        }

        # Step 2: Parse JSON to find connected system node
        NODE_ID=""
        if [ -n "$NODES_RAW" ]; then
            NODE_ID=$(echo "$NODES_RAW" | jq -r '[.nodes // . // [] | .[] | select(.connected == true) | select(.caps | index("system")) | .nodeId] | first // empty' 2>&1) || {
                echo "WARNING: Failed to parse nodes JSON: $NODE_ID"
                echo "  Raw output: $NODES_RAW"
                NODE_ID=""
            }
        fi

        # Step 3: Pin or warn — only set if different from current
        if [ -n "$NODE_ID" ]; then
            CURRENT_NODE=$(openclaw config get tools.exec.node 2>/dev/null) || CURRENT_NODE=""
            if [ "$CURRENT_NODE" = "$NODE_ID" ]; then
                echo "Node pin already correct: ${NODE_ID:0:12}..."
            else
                echo "Pinning exec to connected system node: ${NODE_ID:0:12}..."
                openclaw config set tools.exec.node "$NODE_ID"
            fi
        else
            echo "WARNING: No connected system node found — tools.exec.node not set"
            echo "  Start the node host on your Mac: openclaw node install --host <gateway> --port 443 --tls"
            EXISTING=$(openclaw config get tools.exec.node 2>&1) || true
            if echo "$EXISTING" | grep -q "not found"; then
                echo "  No existing tools.exec.node pin — node exec will fail until a node connects"
            else
                echo "  Keeping existing pin: $EXISTING"
            fi
        fi
      args:
        executable: /bin/bash
      register: node_discovery
      changed_when: node_discovery.stdout is search('Pinning')

    - name: Remove stale sandbox containers after config change
      ansible.builtin.shell: |
        set -euo pipefail
        containers=$(docker ps -q --filter "name=openclaw-sbx-" 2>/dev/null || true)
        if [ -n "$containers" ]; then
          count=$(echo "$containers" | wc -l)
          echo "Removing $count sandbox container(s) to apply new Docker flags"
          echo "$containers" | xargs docker rm -f
        else
          echo "No running sandbox containers to remove"
        fi
      args:
        executable: /bin/bash
      register: sandbox_container_removal
      changed_when: sandbox_container_removal.stdout is search('Removing')
      when: config_settings is changed or config_secrets is changed
      notify: restart openclaw-gateway

  always:
    - name: Clean up secret temp files
      ansible.builtin.file:
        path: "{{ item }}"
        state: absent
      changed_when: false
      loop:
        - /tmp/ansible-gateway-token
        - /tmp/ansible-xai-api-key
        - /tmp/ansible-groq-api-key
        - /tmp/ansible-custom-models
        - /tmp/ansible-model-fallbacks
        - /tmp/ansible-compaction-memoryflush

- name: Enforce agent auth-profiles — setup token present, api-key profile absent
  ansible.builtin.shell: |
    set -euo pipefail
    python3 << 'PYEOF'
    import json, os
    from pathlib import Path

    openclaw_dir = Path(os.path.expanduser("~/.openclaw"))
    token_file = openclaw_dir / "anthropic-auth-token"

    if not token_file.exists():
        print("SKIP: anthropic-auth-token not found")
        raise SystemExit(0)

    token = token_file.read_text().strip()
    changed_agents = []

    for agent_dir in sorted((openclaw_dir / "agents").iterdir()):
        profiles_path = agent_dir / "agent" / "auth-profiles.json"
        if not profiles_path.exists():
            continue

        content = profiles_path.read_text().strip()
        try:
            data = json.loads(content) if content else {}
        except json.JSONDecodeError:
            data = {}

        profiles = data.get("profiles", {})
        original_profiles = dict(profiles)

        # Ensure setup token profile exists with current token
        desired_default = {"type": "token", "provider": "anthropic", "token": token}
        if profiles.get("anthropic:default") != desired_default:
            profiles["anthropic:default"] = desired_default

        # Remove legacy api-key profile
        profiles.pop("anthropic:api-key", None)

        if profiles != original_profiles or not content:
            data["version"] = 1
            data["profiles"] = profiles
            if "lastGood" not in data:
                data["lastGood"] = {"anthropic": "anthropic:default"}
            profiles_path.write_text(json.dumps(data, indent=2) + "\n")
            profiles_path.chmod(0o600)
            changed_agents.append(agent_dir.name)

    if changed_agents:
        print("CHANGED: " + ", ".join(changed_agents))
    else:
        print("OK")
    PYEOF
  args:
    executable: /bin/bash
  register: auth_profiles_result
  changed_when: "'CHANGED:' in auth_profiles_result.stdout"
  notify: restart openclaw-gateway
